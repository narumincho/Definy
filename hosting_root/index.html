<!doctype html>
<html lang="ja">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width,initial-scale=1.0">
    <title>Definy 読み込み中</title>
    <link rel="stylesheet" href="/style.css">
    <link rel="icon" href="/assets/icon.png">
</head>

<body>
    <script src="/main.js"></script>
    <script>
        /* Elmを起動!! */
        const app = Elm.Main.init();
        let prevKeyEvent;
        /* キー入力 */
        window.addEventListener("keydown", (e) => {
            prevKeyEvent = e;
            app.ports.keyDown.send(e);
        });
        /* 直前のキー入力のデフォルト動作を取り消す */
        app.ports.preventDefaultBeforeKeyEvent.subscribe((_) => {
            console.log("直前のキー入力のデフォルト動作を取り消す", prevKeyEvent);
            prevKeyEvent.preventDefault();
            app.ports.keyPrevented.send(null);
        });
        /* テキストエリア(<textarea id="edit">)に値を設定(編集する前の初期設定用) */
        app.ports.setTextAreaValue.subscribe((text) => {
            console.log(`テキストエリア(<textarea id="eidt">)に${text}を設定しようとしている`);
            requestAnimationFrame(() => {
                const edit = document.getElementById("edit");
                if (edit.value !== text) {
                    edit.value = text;
                }
            });
        })
        /* テキストエリア(<textarea id="edit">)に強制的にフォーカスさせる */
        app.ports.focusTextArea.subscribe(e => {
            console.log(`<textarea id="eidt">にフォーカス`);
            requestAnimationFrame(() => {
                document.getElementById("edit").focus();
            })
        })
        /* クリックイベントをキャプチャフェーズで登録する。登録できるのは1つまで */
        const eventAdded = new Map();
        app.ports.setClickEventListenerInCapturePhase.subscribe(id => {
            requestAnimationFrame(() => {
                const element = document.getElementById(id);
                if(element===undefined) {
                    console.log(`id=${id}の要素がない`)
                    return;
                }
                const beforeEventListner = eventAdded.get(id);
                if (beforeEventListner !== undefined) {
                    element.removeEventListener("click", beforeEventListner);
                    console.log(`id=${id}からキャプチャフェーズのクリックイベントを削除`);
                }
                const f = e => {
                    app.ports.fireClickEventInCapturePhase.send(id);
                };
                eventAdded.set(id, f);

                console.log(`id=${id}にキャプチャフェーズのクリックイベントを追加`);

                element.addEventListener("click", f, { capture: true });
            })
        });
        /* クリックイベントをキャプチャフェーズで登録したリスナを削除する */
        // app.ports.deleteClickEventListenerInCapturePhase.subscribe(id => {
        //     document.getElementById(id).removeEventListener("click", eventAdded.get(id));
        //     eventAdded.delete(id)
        // });
        /* コンパイル結果(WASM)を実行 */
        app.ports.run.subscribe(compileResult => {
            WebAssembly.instantiate(new Uint8Array(compileResult.wasm)).then(result => {
                const exportFunc = result.instance.exports;
                const resultValue = exportFunc[0]();
                app.ports.runResult.send({
                    ref: compileResult.ref,
                    index: compileResult.index,
                    result: resultValue
                });
            });
        });
        /* ウィンドウサイズを変えたら */
        const windowResizeSend = (e) => {
            app.ports.windowResize.send({ width: innerWidth, height: innerHeight });
        }
        windowResizeSend();
        window.addEventListener("resize", windowResizeSend);
        window.addEventListener("contextmenu", (e) => {
            // e.preventDefault();
        })
    </script>
</body>

</html>