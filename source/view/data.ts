/* eslint-disable */
/* generated by js-ts-code-generator. Do not edit! */

import * as a from "util";

/**
 * UserId, ProjectIdなどのIdをバイナリ形式にエンコードする
 */
export const encodeId = (value: string): ReadonlyArray<number> =>
  Array.from({ length: 16 }, (_: undefined, i: number): number =>
    Number.parseInt(value.slice(i * 2, i * 2 + 2), 16)
  );

/**
 * バイナリ形式をUserId, ProjectIdなどのIdにデコードする
 * @param index バイナリを読み込み開始位置
 * @param binary バイナリ
 */
export const decodeId = (
  index: number,
  binary: Uint8Array
): { readonly result: string; readonly nextIndex: number } => ({
  result: [...binary.slice(index, index + 16)]
    .map((n: number): string => n.toString(16).padStart(2, "0"))
    .join(""),
  nextIndex: index + 16,
});

/**
 * ImageTokenなどのTokenをバイナリ形式にエンコードする
 */
export const encodeToken = (value: string): ReadonlyArray<number> =>
  Array.from({ length: 32 }, (_: undefined, i: number): number =>
    Number.parseInt(value.slice(i * 2, i * 2 + 2), 16)
  );

/**
 * バイナリ形式をImageTokenなどのTokenにエンコードする
 * @param index バイナリを読み込み開始位置
 * @param binary バイナリ
 */
export const decodeToken = (
  index: number,
  binary: Uint8Array
): { readonly result: string; readonly nextIndex: number } => ({
  result: [...binary.slice(index, index + 32)]
    .map((n: number): string => n.toString(16).padStart(2, "0"))
    .join(""),
  nextIndex: index + 32,
});

/**
 * バイナリと相互変換するための関数
 */
export type Codec<T extends unknown> = {
  readonly encode: (a: T) => ReadonlyArray<number>;
  readonly decode: (
    a: number,
    b: Uint8Array
  ) => { readonly result: T; readonly nextIndex: number };
};

/**
 * プロジェクトの識別子
 * @typePartId 0cd913118a2ad1469d656146a08c5f76
 */
export type ProjectId = string & { readonly _projectId: never };

/**
 * 英語,日本語,エスペラント語などの言語
 * @typePartId 0d9510723f4d34605e41f3a47a8b0ea7
 */
export type Language = "Japanese" | "English" | "Esperanto";

/**
 * -2 147 483 648 ～ 2 147 483 647. 32bit 符号付き整数. JavaScriptのnumberとして扱える. numberの32bit符号あり整数をSigned Leb128のバイナリに変換する
 * @typePartId 16c2d8602e3e5e2d38b9215bd0c44d8d
 */
export type Int32 = number;

/**
 * Unit. 1つの値しかない型. JavaScriptのundefinedで扱う
 * @typePartId 217263d8cdca613c2d1ba77e19d4cbb0
 */
export type Unit = undefined;

/**
 * Maybe. nullableのようなもの. 今後はRustのstd::Optionに出力するために属性をつける?
 * @typePartId 304f21ae8208a21d08731aa6d183742d
 */
export type Maybe<value extends unknown> =
  | { readonly _: "Just"; readonly value: value }
  | { readonly _: "Nothing" };

/**
 * バイナリ. JavaScriptのUint8Arrayで扱える. 最初にLED128でバイト数, その次にバイナリそのまま
 * @typePartId 3e2f740c88923b0393a1ef93d92f157b
 */
export type Binary = Uint8Array;

/**
 * パーツの識別子
 * @typePartId 5880cd7c0b6f0205c739a06181898d03
 */
export type PartId = string & { readonly _partId: never };

/**
 * タグの識別子
 * @typePartId 5ec292c48424e5e9ee8cc2d672830ecd
 */
export type TagId = string & { readonly _tagId: never };

/**
 * 文字列. JavaScriptのstringで扱う. バイナリ形式はUTF-8. 不正な文字が入っている可能性がある
 * @typePartId 666361c9ae68ab64f273c47f3feb8c73
 */
export type String = string;

/**
 * 型パーツの識別子
 * @typePartId 6e3cff317f8bfbbd1391c0afb9ad6b72
 */
export type TypePartId = string & { readonly _typePartId: never };

/**
 * 成功と失敗を表す型. 今後はRustのstd::Resultに出力するために属性をつける?
 * @typePartId 6f937e46fce1cf70d29c54780f132c18
 */
export type Result<ok extends unknown, error extends unknown> =
  | { readonly _: "Ok"; readonly ok: ok }
  | { readonly _: "Error"; readonly error: error };

/**
 * デバッグモードかどうか,言語とページの場所. URLとして表現されるデータ. Googleなどの検索エンジンの都合( https://support.google.com/webmasters/answer/182192?hl=ja )で,URLにページの言語を入れて,言語ごとに別のURLである必要がある. デバッグ時のホスト名は http://localhost になる
 * @typePartId 7210f04a85c5f0f58f7aa20826d67f05
 */
export type UrlData = {
  /**
   * クライアントモード
   */
  readonly clientMode: ClientMode;
  /**
   * 場所
   */
  readonly location: TypePartId;
  /**
   * 言語
   */
  readonly language: Language;
};

/**
 * 日時. 0001-01-01T00:00:00.000Z to 9999-12-31T23:59:59.999Z 最小単位はミリ秒. ミリ秒の求め方は day*1000*60*60*24 + millisecond
 * @typePartId 7d91f0f70643799692aa144ee51a62b1
 */
export type Time = {
  /**
   * 1970-01-01からの経過日数. マイナスになることもある
   */
  readonly day: Int32;
  /**
   * 日にちの中のミリ秒. 0 to 86399999 (=1000*60*60*24-1)
   */
  readonly millisecond: Int32;
};

/**
 * "ソーシャルログインを提供するプロバイダー (例: Google, GitHub)
 * @typePartId 84597034eb252267ce1a599ab7a0b543
 */
export type OpenIdConnectProvider = "Google" | "GitHub";

/**
 * DefinyWebアプリ内での場所を示すもの. URLから求められる. URLに変換できる
 * @typePartId bbcb8e43df8afff9fe24b001c66fb065
 */
export type Location =
  | { readonly _: "Home" }
  | { readonly _: "CreateProject" }
  | { readonly _: "Project"; readonly projectId: ProjectId }
  | { readonly _: "Account"; readonly accountId: AccountId }
  | { readonly _: "Setting" }
  | { readonly _: "About" }
  | { readonly _: "Debug" };

/**
 * アカウントの識別子
 * @typePartId c1a17b07e8e664ca80217833ff2ad3f1
 */
export type AccountId = string & { readonly _accountId: never };

/**
 * リスト. JavaScriptのArrayで扱う
 * @typePartId c3fc2a6cea61086db59e11dc2bef0eee
 */
export type List<element extends unknown> = ReadonlyArray<element>;

/**
 * Bool. 真か偽. JavaScriptのbooleanで扱える. true: 1, false: 0. (1byte)としてバイナリに変換する
 * @typePartId db57caf129f60db969b5b5224a72b937
 */
export type Bool = boolean;

/**
 * アカウントトークン. アカウントトークンを持っていればアクセストークンをDefinyのサーバーにリクエストした際に得られるIDのアカウントを保有していると証明できる. サーバーにハッシュ化したものを保存している. これが盗まれた場合,不正に得た人はアカウントを乗っ取ることができる. 有効期限はなし, 最後に発行したアカウントトークン以外は無効になる
 * @typePartId deb01f82879754c03aa4d244e136e59d
 */
export type AccountToken = string & { readonly _accountToken: never };

/**
 * 画像から求められるトークン.キャッシュのキーとして使われる.1つのトークンに対して永久に1つの画像データしか表さない. キャッシュを更新する必要はない
 * @typePartId e71e15a15b0883940a75e58367151d1a
 */
export type ImageHash = string & { readonly _imageHash: never };

/**
 * デベロップモードか, リリースモード
 * @typePartId ee0590e764618611ffa8e1a0a2e22f79
 */
export type ClientMode = "Develop" | "Release";

/**
 * ログインのURLを発行するために必要なデータ
 * @typePartId f03ea5331c1a3adcde80a04054d35e07
 */
export type RequestLogInUrlRequestData = {
  /**
   * ログインに使用するプロバイダー
   */
  readonly openIdConnectProvider: OpenIdConnectProvider;
  /**
   * ログインした後に返ってくるURLに必要なデータ
   */
  readonly urlData: UrlData;
};

/**
 * DOMからViewを逆算できなかった理由
 * @typePartId af55d0340933969d5f6257c483fa0fd6
 */
export type GetViewError =
  | { readonly _: "UnknownLanguageTag"; readonly string: String }
  | { readonly _: "ThemeColorMetaNotFound" };

/**
 * プロジェクトの識別子
 * @typePartId 0cd913118a2ad1469d656146a08c5f76
 */
export const ProjectId: { readonly codec: Codec<ProjectId> } = {
  codec: {
    encode: (value: ProjectId): ReadonlyArray<number> => encodeId(value),
    decode: (
      index: number,
      binary: Uint8Array
    ): { readonly result: ProjectId; readonly nextIndex: number } =>
      decodeId(index, binary) as {
        readonly result: ProjectId;
        readonly nextIndex: number;
      },
  },
};

/**
 * 英語,日本語,エスペラント語などの言語
 * @typePartId 0d9510723f4d34605e41f3a47a8b0ea7
 */
export const Language: {
  /**
   * 日本語
   */
  readonly Japanese: Language;
  /**
   * 英語
   */
  readonly English: Language;
  /**
   * エスペラント語
   */
  readonly Esperanto: Language;
  readonly codec: Codec<Language>;
} = {
  Japanese: "Japanese",
  English: "English",
  Esperanto: "Esperanto",
  codec: {
    encode: (value: Language): ReadonlyArray<number> => {
      switch (value) {
        case "Japanese": {
          return [0];
        }
        case "English": {
          return [1];
        }
        case "Esperanto": {
          return [2];
        }
      }
    },
    decode: (
      index: number,
      binary: Uint8Array
    ): { readonly result: Language; readonly nextIndex: number } => {
      const patternIndex: {
        readonly result: number;
        readonly nextIndex: number;
      } = Int32.codec.decode(index, binary);
      if (patternIndex.result === 0) {
        return { result: Language.Japanese, nextIndex: patternIndex.nextIndex };
      }
      if (patternIndex.result === 1) {
        return { result: Language.English, nextIndex: patternIndex.nextIndex };
      }
      if (patternIndex.result === 2) {
        return {
          result: Language.Esperanto,
          nextIndex: patternIndex.nextIndex,
        };
      }
      throw new Error("存在しないパターンを指定された 型を更新してください");
    },
  },
};

/**
 * -2 147 483 648 ～ 2 147 483 647. 32bit 符号付き整数. JavaScriptのnumberとして扱える. numberの32bit符号あり整数をSigned Leb128のバイナリに変換する
 * @typePartId 16c2d8602e3e5e2d38b9215bd0c44d8d
 */
export const Int32: { readonly codec: Codec<Int32> } = {
  codec: {
    encode: (value: Int32): ReadonlyArray<number> => {
      let rest: number = value | 0;
      const result: Array<number> = [];
      while (true) {
        const byte: number = rest & 127;
        rest >>= 7;
        if (
          (rest === 0 && (byte & 64) === 0) ||
          (rest === -1 && (byte & 64) !== 0)
        ) {
          result.push(byte);
          return result;
        }
        result.push(byte | 128);
      }
    },
    decode: (
      index: number,
      binary: Uint8Array
    ): { readonly result: Int32; readonly nextIndex: number } => {
      let result: number = 0;
      let offset: number = 0;
      while (true) {
        const byte: number = binary[index + offset];
        result |= (byte & 127) << (offset * 7);
        offset += 1;
        if ((128 & byte) === 0) {
          if (offset * 7 < 32 && (byte & 64) !== 0) {
            return {
              result: result | (~0 << (offset * 7)),
              nextIndex: index + offset,
            };
          }
          return { result, nextIndex: index + offset };
        }
      }
    },
  },
};

/**
 * Unit. 1つの値しかない型. JavaScriptのundefinedで扱う
 * @typePartId 217263d8cdca613c2d1ba77e19d4cbb0
 */
export const Unit: {
  /**
   * Unit型にある.唯一の値
   */
  readonly UnitValue: Unit;
  readonly codec: Codec<Unit>;
} = {
  UnitValue: undefined,
  codec: {
    encode: (value: Unit): ReadonlyArray<number> => [],
    decode: (
      index: number,
      binary: Uint8Array
    ): { readonly result: Unit; readonly nextIndex: number } => ({
      result: Unit.UnitValue,
      nextIndex: index,
    }),
  },
};

/**
 * Maybe. nullableのようなもの. 今後はRustのstd::Optionに出力するために属性をつける?
 * @typePartId 304f21ae8208a21d08731aa6d183742d
 */
export const Maybe: {
  /**
   * 値があるということ
   */
  readonly Just: <value extends unknown>(a: value) => Maybe<value>;
  /**
   * 値がないということ
   */
  readonly Nothing: <value extends unknown>() => Maybe<value>;
  readonly codec: <value extends unknown>(
    a: Codec<value>
  ) => Codec<Maybe<value>>;
} = {
  Just: <value extends unknown>(value: value): Maybe<value> => ({
    _: "Just",
    value,
  }),
  Nothing: <value extends unknown>(): Maybe<value> => ({ _: "Nothing" }),
  codec: <value extends unknown>(
    valueCodec: Codec<value>
  ): Codec<Maybe<value>> => ({
    encode: (value: Maybe<value>): ReadonlyArray<number> => {
      switch (value._) {
        case "Just": {
          return [0].concat(valueCodec.encode(value.value));
        }
        case "Nothing": {
          return [1];
        }
      }
    },
    decode: (
      index: number,
      binary: Uint8Array
    ): { readonly result: Maybe<value>; readonly nextIndex: number } => {
      const patternIndex: {
        readonly result: number;
        readonly nextIndex: number;
      } = Int32.codec.decode(index, binary);
      if (patternIndex.result === 0) {
        const result: {
          readonly result: value;
          readonly nextIndex: number;
        } = valueCodec.decode(patternIndex.nextIndex, binary);
        return {
          result: Maybe.Just(result.result),
          nextIndex: result.nextIndex,
        };
      }
      if (patternIndex.result === 1) {
        return { result: Maybe.Nothing(), nextIndex: patternIndex.nextIndex };
      }
      throw new Error("存在しないパターンを指定された 型を更新してください");
    },
  }),
};

/**
 * バイナリ. JavaScriptのUint8Arrayで扱える. 最初にLED128でバイト数, その次にバイナリそのまま
 * @typePartId 3e2f740c88923b0393a1ef93d92f157b
 */
export const Binary: { readonly codec: Codec<Binary> } = {
  codec: {
    encode: (value: Binary): ReadonlyArray<number> =>
      Int32.codec.encode(value.length).concat([...value]),
    decode: (
      index: number,
      binary: Uint8Array
    ): { readonly result: Binary; readonly nextIndex: number } => {
      const length: {
        readonly result: number;
        readonly nextIndex: number;
      } = Int32.codec.decode(index, binary);
      const nextIndex: number = length.nextIndex + length.result;
      return { result: binary.slice(length.nextIndex, nextIndex), nextIndex };
    },
  },
};

/**
 * パーツの識別子
 * @typePartId 5880cd7c0b6f0205c739a06181898d03
 */
export const PartId: { readonly codec: Codec<PartId> } = {
  codec: {
    encode: (value: PartId): ReadonlyArray<number> => encodeId(value),
    decode: (
      index: number,
      binary: Uint8Array
    ): { readonly result: PartId; readonly nextIndex: number } =>
      decodeId(index, binary) as {
        readonly result: PartId;
        readonly nextIndex: number;
      },
  },
};

/**
 * タグの識別子
 * @typePartId 5ec292c48424e5e9ee8cc2d672830ecd
 */
export const TagId: { readonly codec: Codec<TagId> } = {
  codec: {
    encode: (value: TagId): ReadonlyArray<number> => encodeId(value),
    decode: (
      index: number,
      binary: Uint8Array
    ): { readonly result: TagId; readonly nextIndex: number } =>
      decodeId(index, binary) as {
        readonly result: TagId;
        readonly nextIndex: number;
      },
  },
};

/**
 * 文字列. JavaScriptのstringで扱う. バイナリ形式はUTF-8. 不正な文字が入っている可能性がある
 * @typePartId 666361c9ae68ab64f273c47f3feb8c73
 */
export const String: { readonly codec: Codec<String> } = {
  codec: {
    encode: (value: String): ReadonlyArray<number> => {
      const result: ReadonlyArray<number> = [
        ...new (process === undefined || process.title === "browser"
          ? TextEncoder
          : a.TextEncoder)().encode(value),
      ];
      return Int32.codec.encode(result.length).concat(result);
    },
    decode: (
      index: number,
      binary: Uint8Array
    ): { readonly result: String; readonly nextIndex: number } => {
      const length: {
        readonly result: number;
        readonly nextIndex: number;
      } = Int32.codec.decode(index, binary);
      const nextIndex: number = length.nextIndex + length.result;
      const textBinary: Uint8Array = binary.slice(length.nextIndex, nextIndex);
      const isBrowser: boolean =
        process === undefined || process.title === "browser";
      if (isBrowser) {
        return { result: new TextDecoder().decode(textBinary), nextIndex };
      }
      return { result: new a.TextDecoder().decode(textBinary), nextIndex };
    },
  },
};

/**
 * 型パーツの識別子
 * @typePartId 6e3cff317f8bfbbd1391c0afb9ad6b72
 */
export const TypePartId: { readonly codec: Codec<TypePartId> } = {
  codec: {
    encode: (value: TypePartId): ReadonlyArray<number> => encodeId(value),
    decode: (
      index: number,
      binary: Uint8Array
    ): { readonly result: TypePartId; readonly nextIndex: number } =>
      decodeId(index, binary) as {
        readonly result: TypePartId;
        readonly nextIndex: number;
      },
  },
};

/**
 * 成功と失敗を表す型. 今後はRustのstd::Resultに出力するために属性をつける?
 * @typePartId 6f937e46fce1cf70d29c54780f132c18
 */
export const Result: {
  /**
   * 成功
   */
  readonly Ok: <ok extends unknown, error extends unknown>(
    a: ok
  ) => Result<ok, error>;
  /**
   * 失敗
   */
  readonly Error: <ok extends unknown, error extends unknown>(
    a: error
  ) => Result<ok, error>;
  readonly codec: <ok extends unknown, error extends unknown>(
    a: Codec<ok>,
    b: Codec<error>
  ) => Codec<Result<ok, error>>;
} = {
  Ok: <ok extends unknown, error extends unknown>(
    ok: ok
  ): Result<ok, error> => ({ _: "Ok", ok }),
  Error: <ok extends unknown, error extends unknown>(
    error: error
  ): Result<ok, error> => ({ _: "Error", error }),
  codec: <ok extends unknown, error extends unknown>(
    okCodec: Codec<ok>,
    errorCodec: Codec<error>
  ): Codec<Result<ok, error>> => ({
    encode: (value: Result<ok, error>): ReadonlyArray<number> => {
      switch (value._) {
        case "Ok": {
          return [0].concat(okCodec.encode(value.ok));
        }
        case "Error": {
          return [1].concat(errorCodec.encode(value.error));
        }
      }
    },
    decode: (
      index: number,
      binary: Uint8Array
    ): { readonly result: Result<ok, error>; readonly nextIndex: number } => {
      const patternIndex: {
        readonly result: number;
        readonly nextIndex: number;
      } = Int32.codec.decode(index, binary);
      if (patternIndex.result === 0) {
        const result: {
          readonly result: ok;
          readonly nextIndex: number;
        } = okCodec.decode(patternIndex.nextIndex, binary);
        return {
          result: Result.Ok(result.result),
          nextIndex: result.nextIndex,
        };
      }
      if (patternIndex.result === 1) {
        const result: {
          readonly result: error;
          readonly nextIndex: number;
        } = errorCodec.decode(patternIndex.nextIndex, binary);
        return {
          result: Result.Error(result.result),
          nextIndex: result.nextIndex,
        };
      }
      throw new Error("存在しないパターンを指定された 型を更新してください");
    },
  }),
};

/**
 * デバッグモードかどうか,言語とページの場所. URLとして表現されるデータ. Googleなどの検索エンジンの都合( https://support.google.com/webmasters/answer/182192?hl=ja )で,URLにページの言語を入れて,言語ごとに別のURLである必要がある. デバッグ時のホスト名は http://localhost になる
 * @typePartId 7210f04a85c5f0f58f7aa20826d67f05
 */
export const UrlData: { readonly codec: Codec<UrlData> } = {
  codec: {
    encode: (value: UrlData): ReadonlyArray<number> =>
      ClientMode.codec
        .encode(value.clientMode)
        .concat(TypePartId.codec.encode(value.location))
        .concat(Language.codec.encode(value.language)),
    decode: (
      index: number,
      binary: Uint8Array
    ): { readonly result: UrlData; readonly nextIndex: number } => {
      const clientModeAndNextIndex: {
        readonly result: ClientMode;
        readonly nextIndex: number;
      } = ClientMode.codec.decode(index, binary);
      const locationAndNextIndex: {
        readonly result: TypePartId;
        readonly nextIndex: number;
      } = TypePartId.codec.decode(clientModeAndNextIndex.nextIndex, binary);
      const languageAndNextIndex: {
        readonly result: Language;
        readonly nextIndex: number;
      } = Language.codec.decode(locationAndNextIndex.nextIndex, binary);
      return {
        result: {
          clientMode: clientModeAndNextIndex.result,
          location: locationAndNextIndex.result,
          language: languageAndNextIndex.result,
        },
        nextIndex: languageAndNextIndex.nextIndex,
      };
    },
  },
};

/**
 * 日時. 0001-01-01T00:00:00.000Z to 9999-12-31T23:59:59.999Z 最小単位はミリ秒. ミリ秒の求め方は day*1000*60*60*24 + millisecond
 * @typePartId 7d91f0f70643799692aa144ee51a62b1
 */
export const Time: { readonly codec: Codec<Time> } = {
  codec: {
    encode: (value: Time): ReadonlyArray<number> =>
      Int32.codec
        .encode(value.day)
        .concat(Int32.codec.encode(value.millisecond)),
    decode: (
      index: number,
      binary: Uint8Array
    ): { readonly result: Time; readonly nextIndex: number } => {
      const dayAndNextIndex: {
        readonly result: Int32;
        readonly nextIndex: number;
      } = Int32.codec.decode(index, binary);
      const millisecondAndNextIndex: {
        readonly result: Int32;
        readonly nextIndex: number;
      } = Int32.codec.decode(dayAndNextIndex.nextIndex, binary);
      return {
        result: {
          day: dayAndNextIndex.result,
          millisecond: millisecondAndNextIndex.result,
        },
        nextIndex: millisecondAndNextIndex.nextIndex,
      };
    },
  },
};

/**
 * "ソーシャルログインを提供するプロバイダー (例: Google, GitHub)
 * @typePartId 84597034eb252267ce1a599ab7a0b543
 */
export const OpenIdConnectProvider: {
  /**
   * Google ( https://developers.google.com/identity/sign-in/web/ )
   */
  readonly Google: OpenIdConnectProvider;
  /**
   * GitHub ( https://developer.github.com/v3/guides/basics-of-authentication/ )
   */
  readonly GitHub: OpenIdConnectProvider;
  readonly codec: Codec<OpenIdConnectProvider>;
} = {
  Google: "Google",
  GitHub: "GitHub",
  codec: {
    encode: (value: OpenIdConnectProvider): ReadonlyArray<number> => {
      switch (value) {
        case "Google": {
          return [0];
        }
        case "GitHub": {
          return [1];
        }
      }
    },
    decode: (
      index: number,
      binary: Uint8Array
    ): {
      readonly result: OpenIdConnectProvider;
      readonly nextIndex: number;
    } => {
      const patternIndex: {
        readonly result: number;
        readonly nextIndex: number;
      } = Int32.codec.decode(index, binary);
      if (patternIndex.result === 0) {
        return {
          result: OpenIdConnectProvider.Google,
          nextIndex: patternIndex.nextIndex,
        };
      }
      if (patternIndex.result === 1) {
        return {
          result: OpenIdConnectProvider.GitHub,
          nextIndex: patternIndex.nextIndex,
        };
      }
      throw new Error("存在しないパターンを指定された 型を更新してください");
    },
  },
};

/**
 * DefinyWebアプリ内での場所を示すもの. URLから求められる. URLに変換できる
 * @typePartId bbcb8e43df8afff9fe24b001c66fb065
 */
export const Location: {
  /**
   * 最初のページ
   */
  readonly Home: Location;
  /**
   * プロジェクト作成画面
   */
  readonly CreateProject: Location;
  /**
   * プロジェクトの詳細ページ
   */
  readonly Project: (a: ProjectId) => Location;
  /**
   * アカウント詳細ページ
   */
  readonly Account: (a: AccountId) => Location;
  /**
   * 設定ページ
   */
  readonly Setting: Location;
  /**
   * Definyについて説明したページ
   */
  readonly About: Location;
  /**
   * デバッグページ
   */
  readonly Debug: Location;
  readonly codec: Codec<Location>;
} = {
  Home: { _: "Home" },
  CreateProject: { _: "CreateProject" },
  Project: (projectId: ProjectId): Location => ({ _: "Project", projectId }),
  Account: (accountId: AccountId): Location => ({ _: "Account", accountId }),
  Setting: { _: "Setting" },
  About: { _: "About" },
  Debug: { _: "Debug" },
  codec: {
    encode: (value: Location): ReadonlyArray<number> => {
      switch (value._) {
        case "Home": {
          return [0];
        }
        case "CreateProject": {
          return [1];
        }
        case "Project": {
          return [2].concat(ProjectId.codec.encode(value.projectId));
        }
        case "Account": {
          return [3].concat(AccountId.codec.encode(value.accountId));
        }
        case "Setting": {
          return [4];
        }
        case "About": {
          return [5];
        }
        case "Debug": {
          return [6];
        }
      }
    },
    decode: (
      index: number,
      binary: Uint8Array
    ): { readonly result: Location; readonly nextIndex: number } => {
      const patternIndex: {
        readonly result: number;
        readonly nextIndex: number;
      } = Int32.codec.decode(index, binary);
      if (patternIndex.result === 0) {
        return { result: Location.Home, nextIndex: patternIndex.nextIndex };
      }
      if (patternIndex.result === 1) {
        return {
          result: Location.CreateProject,
          nextIndex: patternIndex.nextIndex,
        };
      }
      if (patternIndex.result === 2) {
        const result: {
          readonly result: ProjectId;
          readonly nextIndex: number;
        } = ProjectId.codec.decode(patternIndex.nextIndex, binary);
        return {
          result: Location.Project(result.result),
          nextIndex: result.nextIndex,
        };
      }
      if (patternIndex.result === 3) {
        const result: {
          readonly result: AccountId;
          readonly nextIndex: number;
        } = AccountId.codec.decode(patternIndex.nextIndex, binary);
        return {
          result: Location.Account(result.result),
          nextIndex: result.nextIndex,
        };
      }
      if (patternIndex.result === 4) {
        return { result: Location.Setting, nextIndex: patternIndex.nextIndex };
      }
      if (patternIndex.result === 5) {
        return { result: Location.About, nextIndex: patternIndex.nextIndex };
      }
      if (patternIndex.result === 6) {
        return { result: Location.Debug, nextIndex: patternIndex.nextIndex };
      }
      throw new Error("存在しないパターンを指定された 型を更新してください");
    },
  },
};

/**
 * アカウントの識別子
 * @typePartId c1a17b07e8e664ca80217833ff2ad3f1
 */
export const AccountId: { readonly codec: Codec<AccountId> } = {
  codec: {
    encode: (value: AccountId): ReadonlyArray<number> => encodeId(value),
    decode: (
      index: number,
      binary: Uint8Array
    ): { readonly result: AccountId; readonly nextIndex: number } =>
      decodeId(index, binary) as {
        readonly result: AccountId;
        readonly nextIndex: number;
      },
  },
};

/**
 * リスト. JavaScriptのArrayで扱う
 * @typePartId c3fc2a6cea61086db59e11dc2bef0eee
 */
export const List: {
  readonly codec: <element extends unknown>(
    a: Codec<element>
  ) => Codec<List<element>>;
} = {
  codec: <element extends unknown>(
    elementCodec: Codec<element>
  ): Codec<List<element>> => ({
    encode: (value: List<element>): ReadonlyArray<number> => {
      let result: Array<number> = Int32.codec.encode(
        value.length
      ) as Array<number>;
      for (const element of value) {
        result = result.concat(elementCodec.encode(element));
      }
      return result;
    },
    decode: (
      index: number,
      binary: Uint8Array
    ): { readonly result: List<element>; readonly nextIndex: number } => {
      const lengthResult: {
        readonly result: number;
        readonly nextIndex: number;
      } = Int32.codec.decode(index, binary);
      let nextIndex: number = lengthResult.nextIndex;
      const result: Array<element> = [];
      for (let i = 0; i < lengthResult.result; i += 1) {
        const resultAndNextIndex: {
          readonly result: element;
          readonly nextIndex: number;
        } = elementCodec.decode(nextIndex, binary);
        result.push(resultAndNextIndex.result);
        nextIndex = resultAndNextIndex.nextIndex;
      }
      return { result, nextIndex };
    },
  }),
};

/**
 * Bool. 真か偽. JavaScriptのbooleanで扱える. true: 1, false: 0. (1byte)としてバイナリに変換する
 * @typePartId db57caf129f60db969b5b5224a72b937
 */
export const Bool: {
  /**
   * 偽
   */
  readonly False: Bool;
  /**
   * 真
   */
  readonly True: Bool;
  readonly codec: Codec<Bool>;
} = {
  False: false,
  True: true,
  codec: {
    encode: (value: Bool): ReadonlyArray<number> => [value ? 1 : 0],
    decode: (
      index: number,
      binary: Uint8Array
    ): { readonly result: Bool; readonly nextIndex: number } => {
      const patternIndex: {
        readonly result: number;
        readonly nextIndex: number;
      } = Int32.codec.decode(index, binary);
      if (patternIndex.result === 0) {
        return { result: Bool.False, nextIndex: patternIndex.nextIndex };
      }
      if (patternIndex.result === 1) {
        return { result: Bool.True, nextIndex: patternIndex.nextIndex };
      }
      throw new Error("存在しないパターンを指定された 型を更新してください");
    },
  },
};

/**
 * アカウントトークン. アカウントトークンを持っていればアクセストークンをDefinyのサーバーにリクエストした際に得られるIDのアカウントを保有していると証明できる. サーバーにハッシュ化したものを保存している. これが盗まれた場合,不正に得た人はアカウントを乗っ取ることができる. 有効期限はなし, 最後に発行したアカウントトークン以外は無効になる
 * @typePartId deb01f82879754c03aa4d244e136e59d
 */
export const AccountToken: { readonly codec: Codec<AccountToken> } = {
  codec: {
    encode: (value: AccountToken): ReadonlyArray<number> => encodeToken(value),
    decode: (
      index: number,
      binary: Uint8Array
    ): { readonly result: AccountToken; readonly nextIndex: number } =>
      decodeToken(index, binary) as {
        readonly result: AccountToken;
        readonly nextIndex: number;
      },
  },
};

/**
 * 画像から求められるトークン.キャッシュのキーとして使われる.1つのトークンに対して永久に1つの画像データしか表さない. キャッシュを更新する必要はない
 * @typePartId e71e15a15b0883940a75e58367151d1a
 */
export const ImageHash: { readonly codec: Codec<ImageHash> } = {
  codec: {
    encode: (value: ImageHash): ReadonlyArray<number> => encodeToken(value),
    decode: (
      index: number,
      binary: Uint8Array
    ): { readonly result: ImageHash; readonly nextIndex: number } =>
      decodeToken(index, binary) as {
        readonly result: ImageHash;
        readonly nextIndex: number;
      },
  },
};

/**
 * デベロップモードか, リリースモード
 * @typePartId ee0590e764618611ffa8e1a0a2e22f79
 */
export const ClientMode: {
  /**
   * ローカルで開発するときのモード. オリジンは http://localshot:2520
   */
  readonly Develop: ClientMode;
  /**
   * リリースモード. オリジンは https://definy.app
   */
  readonly Release: ClientMode;
  readonly codec: Codec<ClientMode>;
} = {
  Develop: "Develop",
  Release: "Release",
  codec: {
    encode: (value: ClientMode): ReadonlyArray<number> => {
      switch (value) {
        case "Develop": {
          return [0];
        }
        case "Release": {
          return [1];
        }
      }
    },
    decode: (
      index: number,
      binary: Uint8Array
    ): { readonly result: ClientMode; readonly nextIndex: number } => {
      const patternIndex: {
        readonly result: number;
        readonly nextIndex: number;
      } = Int32.codec.decode(index, binary);
      if (patternIndex.result === 0) {
        return {
          result: ClientMode.Develop,
          nextIndex: patternIndex.nextIndex,
        };
      }
      if (patternIndex.result === 1) {
        return {
          result: ClientMode.Release,
          nextIndex: patternIndex.nextIndex,
        };
      }
      throw new Error("存在しないパターンを指定された 型を更新してください");
    },
  },
};

/**
 * ログインのURLを発行するために必要なデータ
 * @typePartId f03ea5331c1a3adcde80a04054d35e07
 */
export const RequestLogInUrlRequestData: {
  readonly codec: Codec<RequestLogInUrlRequestData>;
} = {
  codec: {
    encode: (value: RequestLogInUrlRequestData): ReadonlyArray<number> =>
      OpenIdConnectProvider.codec
        .encode(value.openIdConnectProvider)
        .concat(UrlData.codec.encode(value.urlData)),
    decode: (
      index: number,
      binary: Uint8Array
    ): {
      readonly result: RequestLogInUrlRequestData;
      readonly nextIndex: number;
    } => {
      const openIdConnectProviderAndNextIndex: {
        readonly result: OpenIdConnectProvider;
        readonly nextIndex: number;
      } = OpenIdConnectProvider.codec.decode(index, binary);
      const urlDataAndNextIndex: {
        readonly result: UrlData;
        readonly nextIndex: number;
      } = UrlData.codec.decode(
        openIdConnectProviderAndNextIndex.nextIndex,
        binary
      );
      return {
        result: {
          openIdConnectProvider: openIdConnectProviderAndNextIndex.result,
          urlData: urlDataAndNextIndex.result,
        },
        nextIndex: urlDataAndNextIndex.nextIndex,
      };
    },
  },
};

/**
 * DOMからViewを逆算できなかった理由
 * @typePartId af55d0340933969d5f6257c483fa0fd6
 */
export const GetViewError: {
  /**
   * 不明な lang を指定していた
   */
  readonly UnknownLanguageTag: (a: String) => GetViewError;
  /**
   * theme-color の指定をしたmeta要素が見つけられなかった
   */
  readonly ThemeColorMetaNotFound: GetViewError;
  readonly codec: Codec<GetViewError>;
} = {
  UnknownLanguageTag: (string_: String): GetViewError => ({
    _: "UnknownLanguageTag",
    string: string_,
  }),
  ThemeColorMetaNotFound: { _: "ThemeColorMetaNotFound" },
  codec: {
    encode: (value: GetViewError): ReadonlyArray<number> => {
      switch (value._) {
        case "UnknownLanguageTag": {
          return [0].concat(String.codec.encode(value.string));
        }
        case "ThemeColorMetaNotFound": {
          return [1];
        }
      }
    },
    decode: (
      index: number,
      binary: Uint8Array
    ): { readonly result: GetViewError; readonly nextIndex: number } => {
      const patternIndex: {
        readonly result: number;
        readonly nextIndex: number;
      } = Int32.codec.decode(index, binary);
      if (patternIndex.result === 0) {
        const result: {
          readonly result: String;
          readonly nextIndex: number;
        } = String.codec.decode(patternIndex.nextIndex, binary);
        return {
          result: GetViewError.UnknownLanguageTag(result.result),
          nextIndex: result.nextIndex,
        };
      }
      if (patternIndex.result === 1) {
        return {
          result: GetViewError.ThemeColorMetaNotFound,
          nextIndex: patternIndex.nextIndex,
        };
      }
      throw new Error("存在しないパターンを指定された 型を更新してください");
    },
  },
};
